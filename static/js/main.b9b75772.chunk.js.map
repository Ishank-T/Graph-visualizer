{"version":3,"sources":["PathfindingVisualizer/Node/Node.js","PathfindingVisualizer/Algorithms/dfs.js","PathfindingVisualizer/Algorithms/dijkstra.js","PathfindingVisualizer/Mazes/maze.js","PathfindingVisualizer/Mazes/weightMaze.js","Navbar.js","PathfindingVisualizer/Mazes/hSkewMaze.js","PathfindingVisualizer/Mazes/vSkewMaze.js","Data Structures/disjointSetItem.js","Data Structures/disjointSet.js","PathfindingVisualizer/Mazes/kruskalsMaze1.js","PathfindingVisualizer/Mazes/primsMaze.js","PathfindingVisualizer/PathfindingVisualizer.js","PathfindingVisualizer/Mazes/wallMaze.js","PathfindingVisualizer/Algorithms/bfs.js","Canvas/CanvasContext.js","Canvas/CanvasBoard.js","Canvas/Algorithms/bfs.js","Canvas/Algorithms/dfs.js","Canvas/Algorithms/dijkstra.js","Canvas/Algorithms/visitAllEdges.js","Canvas/Algorithms/kruskals.js","Canvas/Algorithms/prims.js","Canvas/Canvas.js","App.js","index.js"],"names":["Node","props","this","row","col","weight","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseLeave","extraClassName","id","className","React","Component","getChildren","node","grid","childElements","forEach","direction","childRow","childCol","length","child","isVisited","push","childNodes","childNode","costFromSource","parent","Math","min","extractMinIndex","dijkstraPQ","minNode","minNodeIndex","i","currentNode","createNode","finishNode","startNode","srow","scol","frow","fcol","isNode","Number","POSITIVE_INFINITY","removeWall","nodeA","nodeB","rowA","colA","rowB","colB","r","floor","c","maze","rowNum","colNum","newNode","initialGrid","dfsStack","random","pop","weightMaze","Navbar","onVisualizeClick","state","visualize","bfs","dfs","dijkstra","alert","toggleCanvas","bfsClick","setState","dfsClick","dijkstraClick","onWeightWallToggleClick","weightOrWall","weightWallToggle","isCanvas","clearGrid","resetGrid","mazify","hmazify","vmazify","kruskalMazify","primMazify","weightMazify","wallMazify","clearWallsandWeights","kruskalMST","primMST","mazeOptions","data-toggle","href","onClick","weightAndWallOption","addWeightOption","type","vChildElements","hChildElements","horizontalSkewMaze","random1","verticalSkewMaze","DisjointSetItem","value","keyCallback","children","isRoot","getRoot","rank","getRank","Object","values","parentItem","forceSettingParentChild","addChild","childItem","getKey","setParent","DisjointSet","items","itemValue","disjointSetItem","templateDisjointItem","requiredDisjointItem","valueA","valueB","rootKeyA","find","rootKeyB","Error","rootA","rootB","disjointSet","index","hWallSet","vWallSet","kruskalMaze","makeSet","random2","neighborNodeRight","neighborNodeLeft","inSameSet","union","splice","unionJoint","primMaze","edgeQueue","PathfindingVisualizer","toggleIsRunning","isRunning","toggleWeightWallToggle","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","getInitialGrid","rowCount","ROW_COUNT","colCount","COLUMN_COUNT","currentRow","document","getElementById","onCellDown","mouseIsPressed","startNodePressed","finishNodePressed","onCellEnter","onCellLeave","onCellRelease","mazes","mazeType","wallMaze","componentWillMount","documentElement","clientHeight","clientWidth","componentDidMount","nodesInShortestPathOrder","unshift","algo","visitedNodesInOrder","minIndex","bfsQueue","childDirections","shift","x","y","getNodesInShortestPathOrder","animate","setTimeout","animateShortestPath","nodeClassName","navbarHeight","map","rowID","nodeID","CanvasContext","createContext","CanvasProvider","useState","isDrawing","setIsDrawing","nodeDrawing","setNodeDrawing","setIndex","canvasRef","useRef","contextRef","nodesOfGraph","pushNode","squareDistance","pow","centerX","centerY","setStartNode","currentCoordinates","whichNode","writeText","info","style","canvas","current","ctx","getContext","text","fontSize","fontFamily","color","textAlign","textBaseline","beginPath","font","fillStyle","fillText","stroke","currentEdgeWeight","setCurrentEdgeWeight","Provider","prepareCanvas","height","width","context","lineCap","strokeStyle","lineWidth","startDrawing","nativeEvent","offsetX","offsetY","prevIndex","arc","PI","closePath","start","moveTo","finishDrawing","end","lineTo","clearCanvas","fillRect","draw","toggleNodeDrawing","CanvasBoard","useContext","useEffect","settingStartNode","settingEndNode","endNode","setEndNode","settingGraph","emptyGraphCall","toggleEmptyTheGraph","setWeight","edgeWeightInput","onChange","event","parseInt","target","class","placeholder","startIndex","endIndex","onMouseMove","ref","graph","visitedEdgesInOrder","xB","yB","xA","yA","createEdge","childObject","compare","edgeA","edgeB","edgeWeight","getEdgeWeight","Canvas","canvasOrGrid","graphOfNodes","redrawGraph","edge","visitAllEdges","fill","shortestPathNodes","visualizeMST","MSTedges","graphEdges","sort","kruskalSelectedEdges","kruskalsMST","primSelectedEdges","graphEdgesQueue","primsMST","animateMST","visitedNodesInOrder1","visitedEdgesInOrder1","console","log","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.b9b75772.chunk.js","sourcesContent":["// jsx for each node AKA eac cel on the grid\r\nimport React from 'react';\r\nimport './Node.css'\r\nclass Node extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n    }\r\n    render() {\r\n        const {\r\n            row,\r\n            col,\r\n            weight,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            onMouseLeave,\r\n        } = this.props;\r\n        const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : isWall ? \"node-wall\" : \"\";\r\n        return (\r\n            <td\r\n                id={`node-${row}-${col}`}\r\n                className={`node ${extraClassName}`}\r\n                onMouseDown={() => onMouseDown(row, col)}\r\n                onMouseEnter={() => onMouseEnter(row, col)}\r\n                onMouseUp={() => onMouseUp()}\r\n                onMouseLeave={() => onMouseLeave(row, col)}\r\n            ><b>{weight === 1 ? \"\" : weight}</b></td> // It is used to create the grid.\r\n        );\r\n    }\r\n}\r\nexport default Node;","// DFS\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const childDirections = [[1, 0], [0, 1], [-1, 0], [0, -1]];\r\n\r\n    childDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited && !child.isWall) {\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\n\r\nexport function dfs(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [startNode];\r\n    startNode.isVisited= true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else { \r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length-1];\r\n        }\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n","// Dijkstra\r\n\r\nfunction getChildren (grid,node){\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]];\r\n    const childNodes = [];\r\n    const {row,col} = node;\r\n    childDirections.forEach(direction=>{\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n\r\n        if(childRow >=0&& childCol>=0 && childCol<grid[0].length && childRow<grid.length)\r\n        {\r\n            const childNode = grid[childRow][childCol];\r\n            if(!childNode.isVisited && !childNode.isWall)\r\n            {\r\n                childNodes.push(childNode);\r\n                if(childNode.costFromSource > node.costFromSource + childNode.weight)\r\n                {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n            }\r\n            else if(childNode.isVisited)\r\n            {\r\n                if (childNode.costFromSource > node.costFromSource + childNode.weight) {\r\n                    childNode.parent = node;\r\n                }\r\n                childNode.costFromSource = Math.min(childNode.costFromSource, node.costFromSource + childNode.weight);\r\n            }\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex (dijkstraPQ){\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex=0;\r\n    for(let i=1;i<dijkstraPQ.length;i++)\r\n    {\r\n        let currentNode = dijkstraPQ[i];\r\n        if(minNode.costFromSource > currentNode.costFromSource)\r\n        {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(grid,startNode,finishNode){\r\n    const visitedNodesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.isVisited=true;\r\n    while(dijkstraPQ.length)\r\n    {\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if(currentNode.isFinish) return visitedNodesInOrder;\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(grid,currentNode);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited=true;\r\n        });\r\n        dijkstraPQ.splice(minIndex,1);\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const childDirections = [[2, 0], [0, 2], [-2, 0], [0, -2]];\r\n\r\n    childDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                // child.isVisited = true;\r\n                childElements.push(child);\r\n            }\r\n        }\r\n    })\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\n\r\nexport function maze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements.length) {\r\n            const random = Math.floor(Math.random() * childElements.length);\r\n            removeWall(currentNode, childElements[random], grid);\r\n            currentNode = childElements[random];\r\n            currentNode.isVisited = true;\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}\r\n\r\n","function distribution() {\r\n    const random1 = Math.random();\r\n    if (random1 < 0.5) {\r\n        const random2 = Math.floor(Math.random() * 10 + 1);\r\n        return random2;\r\n    }\r\n    return 1;\r\n}\r\nexport function weightMaze(grid) {\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            if (!node.isWall) {\r\n                node.weight = distribution();\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nclass Navbar extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            visualize: '',\r\n            weightOrWall: false,\r\n            isCanvas: this.props.isCanvas,\r\n        }\r\n    }\r\n    onVisualizeClick = () => {\r\n        const visualize = this.state.visualize;\r\n        switch (visualize) {\r\n            case 'BFS':\r\n                this.props.bfs();\r\n                break;\r\n            case 'DFS':\r\n                this.props.dfs();\r\n                break;\r\n            case 'Dijkstra':\r\n                this.props.dijkstra();\r\n                break;\r\n            default:\r\n                alert('Choose an algorithm for visualization!!');\r\n        }\r\n    }\r\n    toggleCanvas = () => {\r\n        this.props.toggleCanvas();\r\n    }\r\n    bfsClick = () => {\r\n        this.setState({ visualize: 'BFS' });\r\n    }\r\n    dfsClick = () => {\r\n        this.setState({ visualize: 'DFS' });\r\n    }\r\n    dijkstraClick = () => {\r\n        this.setState({ visualize: 'Dijkstra' });\r\n    }\r\n    onWeightWallToggleClick = () => {\r\n        const weightOrWall = !this.state.weightOrWall;\r\n        this.setState({ weightOrWall });\r\n        this.props.weightWallToggle();\r\n    }\r\n    render() {\r\n        const {\r\n            clearGrid,\r\n            resetGrid,\r\n            mazify,\r\n            hmazify,\r\n            vmazify,\r\n            kruskalMazify,\r\n            primMazify,\r\n            weightMazify,\r\n            wallMazify,\r\n            clearWallsandWeights,\r\n            kruskalMST,\r\n            primMST,\r\n        } = this.props;\r\n\r\n        let mazeOptions = <li className=\"dropdown\">\r\n            <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Mazes &amp; Patterns\r\n             <span className=\"caret\"></span></a>\r\n            <ul className=\"dropdown-menu\">\r\n                <li id='startButtonCreateMazeTwo'><a href=\"#\" onClick={mazify}>Recursive Division</a></li>\r\n                <li id='startButtonCreateMazeThree'><a href=\"#\" onClick={vmazify}>Recursive Division (vertical skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={hmazify}>Recursive Division (horizontal skew)</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMazify}>Kruskal's Maze</a></li>\r\n                <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMazify}>Prims's Maze</a></li>\r\n                <li id='startButtonCreateMazeOne'><a href=\"#\" onClick={wallMazify}>Basic Random Maze</a></li>\r\n                <li id='startButtonCreateMazeWeights'><a href=\"#\" onClick={weightMazify}>Basic Weight Maze</a></li>\r\n            </ul>\r\n        </li>;\r\n        let weightAndWallOption = <li id='startButtonClearWalls'><a href=\"#\" onClick={clearWallsandWeights}>Clear Walls &amp; Weights</a></li>;\r\n        let addWeightOption = <li id='startButtonAddObject'><a href=\"#\" onClick={this.onWeightWallToggleClick}>Add {this.state.weightOrWall ? 'Wall' : 'Weight'}</a></li>;\r\n        if(this.state.isCanvas){\r\n            mazeOptions = <li className=\"dropdown\">\r\n                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Minimum Spanning Tree\r\n             <span className=\"caret\"></span></a>\r\n                <ul className=\"dropdown-menu\">\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={kruskalMST}>Kruskal's Algorithm</a></li>\r\n                    <li id='startButtonCreateMazeFour'><a href=\"#\" onClick={primMST}>Prims's Algorithm</a></li>\r\n                </ul>\r\n            </li>;\r\n            weightAndWallOption = <li></li>;\r\n            addWeightOption = <li></li>;\r\n        }\r\n\r\n        return (\r\n            <div id='navbarDiv'>\r\n                <nav className=\"navbar navbar-inverse\">\r\n                    <div className=\"container-fluid\">\r\n                        <div className=\"navbar-header\">\r\n                            <a id=\"refreshButton\" className=\"navbar-brand\" href=\"#\">Graph Visualizer</a>\r\n                        </div>\r\n                        <ul className=\"nav navbar-nav\">\r\n                            <li className=\"dropdown\">\r\n                                <a className=\"dropdown-toggle\" data-toggle=\"dropdown\" href=\"#\">Algorithms\r\n             <span className=\"caret\"></span></a>\r\n                                <ul className=\"dropdown-menu\">\r\n                                    <li id='startButtonDijkstra'><a href=\"#\" onClick={this.dijkstraClick}>Dijkstra's Algorithm</a></li>\r\n                                    <li id='startButtonBFS'><a href=\"#\" onClick={this.bfsClick}>Breadth-first Search</a></li>\r\n                                    <li id='startButtonDFS'><a href=\"#\" onClick={this.dfsClick}>Depth-first Search</a></li>\r\n                                </ul>\r\n                            </li>\r\n                            {mazeOptions}\r\n                            {addWeightOption}\r\n                            <li id='startButtonStart'><button id=\"actualStartButton\" className=\"btn btn-default navbar-btn\" type=\"button\" onClick={this.onVisualizeClick}>Visualize {this.state.visualize}!</button></li>\r\n                            <li id='startButtonClearBoard'><a href=\"#\" onClick={resetGrid}>Clear Board</a></li>\r\n                            {weightAndWallOption}\r\n                            <li id='startButtonClearPath'><a href=\"#\" onClick={clearGrid}>Clear Path</a></li>\r\n                            <li id='startButtonAddObject'><a href=\"#\" onClick={this.toggleCanvas}>Switch to {this.state.isCanvas ? 'Grid' : 'Canvas'}</a></li>\r\n                        </ul>\r\n                    </div>\r\n                </nav>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default Navbar;","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\n\r\nexport function horizontalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}","function createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n    };\r\n}\r\n\r\n// assumed rowNum ans colNum are odd\r\n\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    const grid = [];\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) newNode.isWall = true;\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const { row, col } = node;\r\n    const childElements = [];\r\n    const hChildDirections = [[2, 0], [-2, 0]];\r\n    const vChildDirections = [[0, 2], [0, -2]];\r\n\r\n    const hChildElements = [];\r\n    hChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                hChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(hChildElements);\r\n\r\n    const vChildElements = [];\r\n    vChildDirections.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow >= 0 && childCol >= 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const child = grid[childRow][childCol];\r\n            if (!child.isVisited) {\r\n                vChildElements.push(child);\r\n            }\r\n        }\r\n    });\r\n    childElements.push(vChildElements);\r\n    return childElements;\r\n}\r\n\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\n\r\nexport function verticalSkewMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    let dfsStack = [currentNode];\r\n\r\n    while (dfsStack.length) {\r\n        const childElements = getChildren(currentNode, grid);\r\n        if (childElements[0].length || childElements[1].length) {\r\n            const random1 = Math.floor(Math.random() * 4);\r\n            if (random1 !== 3 && childElements[0].length) {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (random1 === 3 && childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else if (childElements[1].length) {\r\n                const random = Math.floor(Math.random() * childElements[1].length);\r\n                removeWall(currentNode, childElements[1][random], grid);\r\n                currentNode = childElements[1][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n            else {\r\n                const random = Math.floor(Math.random() * childElements[0].length);\r\n                removeWall(currentNode, childElements[0][random], grid);\r\n                currentNode = childElements[0][random];\r\n                currentNode.isVisited = true;\r\n                dfsStack.push(currentNode);\r\n            }\r\n        }\r\n        else {\r\n            currentNode = dfsStack.pop();\r\n        }\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}\r\n\r\n","export default class DisjointSetItem {\r\n    /**\r\n     * @param {*} value\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(value, keyCallback) {\r\n        this.value = value;\r\n        this.keyCallback = keyCallback;\r\n        /** @var {DisjointSetItem} this.parent */\r\n        this.parent = null;\r\n        this.children = {};\r\n    }\r\n\r\n    /**\r\n     * @return {*}\r\n     */\r\n    getKey() {\r\n        // Allow user to define custom key generator.\r\n        if (this.keyCallback) {\r\n            return this.keyCallback(this.value);\r\n        }\r\n\r\n        // Otherwise use value as a key by default.\r\n        return this.value;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem}\r\n     */\r\n    getRoot() {\r\n        return this.isRoot() ? this : this.parent.getRoot();\r\n    }\r\n\r\n    /**\r\n     * @return {boolean}\r\n     */\r\n    isRoot() {\r\n        return this.parent === null;\r\n    }\r\n\r\n    /**\r\n     * Rank basically means the number of all ancestors.\r\n     *\r\n     * @return {number}\r\n     */\r\n    getRank() {\r\n        if (this.getChildren().length === 0) {\r\n            return 0;\r\n        }\r\n\r\n        let rank = 0;\r\n\r\n        /** @var {DisjointSetItem} child */\r\n        this.getChildren().forEach((child) => {\r\n            // Count child itself.\r\n            rank += 1;\r\n\r\n            // Also add all children of current child.\r\n            rank += child.getRank();\r\n        });\r\n\r\n        return rank;\r\n    }\r\n\r\n    /**\r\n     * @return {DisjointSetItem[]}\r\n     */\r\n    getChildren() {\r\n        return Object.values(this.children);\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} parentItem\r\n     * @param {boolean} forceSettingParentChild\r\n     * @return {DisjointSetItem}\r\n     */\r\n    setParent(parentItem, forceSettingParentChild = true) {\r\n        this.parent = parentItem;\r\n        if (forceSettingParentChild) {\r\n            parentItem.addChild(this);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {DisjointSetItem} childItem\r\n     * @return {DisjointSetItem}\r\n     */\r\n    addChild(childItem) {\r\n        this.children[childItem.getKey()] = childItem;\r\n        childItem.setParent(this, false);\r\n\r\n        return this;\r\n    }\r\n}","import DisjointSetItem from './disjointSetItem';\r\n\r\nexport default class DisjointSet {\r\n    /**\r\n     * @param {function(value: *)} [keyCallback]\r\n     */\r\n    constructor(keyCallback) {\r\n        this.keyCallback = keyCallback;\r\n        this.items = {};\r\n    }\r\n\r\n    /**\r\n     * @param {*} itemValue\r\n     * @return {DisjointSet}\r\n     */\r\n    makeSet(itemValue) {\r\n        const disjointSetItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        if (!this.items[disjointSetItem.getKey()]) {\r\n            // Add new item only in case if it not presented yet.\r\n            this.items[disjointSetItem.getKey()] = disjointSetItem;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Find set representation node.\r\n     *\r\n     * @param {*} itemValue\r\n     * @return {(string|null)}\r\n     */\r\n    find(itemValue) {\r\n        const templateDisjointItem = new DisjointSetItem(itemValue, this.keyCallback);\r\n\r\n        // Try to find item itself;\r\n        const requiredDisjointItem = this.items[templateDisjointItem.getKey()];\r\n\r\n        if (!requiredDisjointItem) {\r\n            return null;\r\n        }\r\n\r\n        return requiredDisjointItem.getRoot().getKey();\r\n    }\r\n\r\n    /**\r\n     * Union by rank.\r\n     *\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {DisjointSet}\r\n     */\r\n    union(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        if (rootKeyA === rootKeyB) {\r\n            // In case if both elements are already in the same set then just return its key.\r\n            return this;\r\n        }\r\n\r\n        const rootA = this.items[rootKeyA];\r\n        const rootB = this.items[rootKeyB];\r\n\r\n        if (rootA.getRank() < rootB.getRank()) {\r\n            // If rootB's tree is bigger then make rootB to be a new root.\r\n            rootB.addChild(rootA);\r\n\r\n            return this;\r\n        }\r\n\r\n        // If rootA's tree is bigger then make rootA to be a new root.\r\n        rootA.addChild(rootB);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @param {*} valueA\r\n     * @param {*} valueB\r\n     * @return {boolean}\r\n     */\r\n    inSameSet(valueA, valueB) {\r\n        const rootKeyA = this.find(valueA);\r\n        const rootKeyB = this.find(valueB);\r\n\r\n        if (rootKeyA === null || rootKeyB === null) {\r\n            throw new Error('One or two values are not in sets');\r\n        }\r\n\r\n        return rootKeyA === rootKeyB;\r\n    }\r\n}","// with data structure\r\n// working fine\r\nimport DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node) => {\r\n    return node.index;\r\n});\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nlet hWallSet = [];\r\nlet vWallSet = [];\r\nlet rootNodeIndex = [];\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    hWallSet = [];\r\n    vWallSet = [];\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n                if (c % 2 === 0 && r % 2 === 1 && c > 0 && c < colNum - 1) {\r\n                    hWallSet.push(newNode);\r\n                }\r\n                else if (r % 2 === 0 && c % 2 === 1 && r > 0 && r < rowNum - 1) {\r\n                    vWallSet.push(newNode);\r\n                }\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                // rootNodeIndex.push(i);\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\nexport function kruskalMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n    while (hWallSet.length || vWallSet.length) {\r\n        const random1 = Math.floor(Math.random() * 2);\r\n        if (random1 && hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (!random1 && vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n        else if (hWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * hWallSet.length);\r\n            const node = hWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row][col + 1];\r\n            const neighborNodeLeft = grid[row][col - 1];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            hWallSet.splice(random2, 1);\r\n        }\r\n        else if (vWallSet.length) {\r\n            const random2 = Math.floor(Math.random() * vWallSet.length);\r\n            const node = vWallSet[random2];\r\n            const { row, col } = node;\r\n            const neighborNodeRight = grid[row + 1][col];\r\n            const neighborNodeLeft = grid[row - 1][col];\r\n            if (!disjointSet.inSameSet(neighborNodeLeft, neighborNodeRight)) {\r\n                node.isWall = false;\r\n                disjointSet.union(neighborNodeLeft, neighborNodeRight);\r\n            }\r\n            vWallSet.splice(random2, 1);\r\n        }\r\n    }\r\n    return grid;\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\nlet disjointSet = new DisjointSet((node) => {\r\n    return node.index;\r\n});\r\n\r\nfunction createNode(row, col, finishNode, startNode) {\r\n    const srow = startNode.row;\r\n    const scol = startNode.col;\r\n    const frow = finishNode.row;\r\n    const fcol = finishNode.col;\r\n    return {\r\n        row: row,\r\n        col: col,\r\n        isVisited: false,\r\n        isWall: false,\r\n        parent: null,\r\n        isNode: true,\r\n        isStart:\r\n            row === srow && col === scol,\r\n        isFinish:\r\n            row === frow && col === fcol,\r\n        weight: 1,\r\n        costFromSource: (row === srow && col === scol) ? 0 : Number.POSITIVE_INFINITY,\r\n        index: -1,\r\n    };\r\n}\r\nfunction initialGrid(rowNum, colNum, startNode, finishNode) {\r\n    disjointSet = new DisjointSet((node) => {\r\n        return node.index;\r\n    });\r\n    const grid = [];\r\n    let i = 0;\r\n    for (let r = 0; r < rowNum; r++) {\r\n        const row = [];\r\n        for (let c = 0; c < colNum; c++) {\r\n            const newNode = createNode(r, c, finishNode, startNode);\r\n            if ((r % 2 == 0 || c % 2 == 0)) {\r\n                newNode.isWall = true;\r\n            }\r\n            else {\r\n                newNode.index = i;\r\n                i++;\r\n                disjointSet.makeSet(newNode);\r\n            }\r\n            if (newNode.isFinish || newNode.isStart) newNode.isWall = false;\r\n            row.push(newNode);\r\n        }\r\n        grid.push(row);\r\n    }\r\n    return grid;\r\n}\r\n\r\nfunction getChildren(node, grid) {\r\n    const childDirection = [[2, 0], [0, 2], [-2, 0], [0, -2]];\r\n    const children = [];\r\n    const { row, col } = node;\r\n    childDirection.forEach(direction => {\r\n        const childRow = row + direction[0];\r\n        const childCol = col + direction[1];\r\n        if (childRow > 0 && childCol > 0 && childRow < grid.length && childCol < grid[0].length) {\r\n            const childNode = grid[childRow][childCol];\r\n            children.push(childNode);\r\n        }\r\n    });\r\n    return children;\r\n}\r\nfunction removeWall(nodeA, nodeB, grid) {\r\n\r\n    const rowA = nodeA.row;\r\n    const colA = nodeA.col;\r\n    const rowB = nodeB.row;\r\n    const colB = nodeB.col;\r\n\r\n    const r = Math.floor((rowA + rowB) / 2);\r\n    const c = Math.floor((colA + colB) / 2);\r\n\r\n    grid[r][c].isWall = false;\r\n    return;\r\n}\r\nfunction unionJoint(node, currentNode, grid) {\r\n    const children = getChildren(node, grid);\r\n    children.forEach(child => {\r\n        if (disjointSet.inSameSet(child, currentNode) && !disjointSet.inSameSet(currentNode, node)) {\r\n            removeWall(child, node, grid);\r\n            disjointSet.union(currentNode, node);\r\n        }\r\n    });\r\n    return;\r\n}\r\nexport function primMaze(rowNum, colNum, startNode, finishNode) {\r\n    const grid = initialGrid(rowNum, colNum, startNode, finishNode);\r\n\r\n    let currentNode = grid[1][1];\r\n    const edgeQueue = [grid[3][1], grid[1][3]];\r\n    grid[3][1].isVisited = true;\r\n    grid[1][3].isVisited = true;\r\n    while (edgeQueue.length) {\r\n        const random = Math.floor(Math.random() * edgeQueue.length);\r\n        unionJoint(edgeQueue[random], currentNode, grid);\r\n        currentNode = edgeQueue[random];\r\n        const children = getChildren(currentNode, grid);\r\n        if (children.length) {\r\n            children.forEach(child => {\r\n                if (!child.isVisited) {\r\n                    edgeQueue.push(child);\r\n                    child.isVisited = true;\r\n                }\r\n            });\r\n        }\r\n        edgeQueue.splice(random, 1);\r\n    }\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isVisited = false;\r\n        });\r\n    });\r\n    return grid;\r\n}","import React from 'react';\r\nimport Node from './Node/Node';\r\nimport './PathfindingVisualizer.css'\r\nimport { bfs } from './Algorithms/bfs'\r\nimport { dfs } from './Algorithms/dfs'\r\nimport { dijkstra } from './Algorithms/dijkstra'\r\nimport { maze } from './Mazes/maze'\r\nimport { weightMaze } from './Mazes/weightMaze'\r\nimport { wallMaze } from './Mazes/wallMaze'\r\nimport Navbar from '../Navbar';\r\nimport { horizontalSkewMaze } from './Mazes/hSkewMaze';\r\nimport { verticalSkewMaze } from './Mazes/vSkewMaze';\r\nimport { kruskalMaze } from './Mazes/kruskalsMaze1';\r\nimport { primMaze } from './Mazes/primsMaze';\r\n\r\nclass PathfindingVisualizer extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            grid: [],\r\n            ROW_COUNT: 25,\r\n            COLUMN_COUNT: 35,\r\n            START_NODE_ROW: 5,\r\n            FINISH_NODE_ROW: 20,\r\n            START_NODE_COL: 5,\r\n            FINISH_NODE_COL: 30,\r\n            isRunning: false,                    // to check if any process is running at any instant\r\n            mouseIsPressed: false,               // to check if mouse is pressed at any instant\r\n            startNodePressed: false,             // to check if startnode is being dragged\r\n            finishNodePressed: false,            // to check if endnode is being dragged\r\n            weightWallToggle: false,\r\n        };\r\n\r\n    }\r\n\r\n    // Toggle state functions\r\n    toggleIsRunning = () => {\r\n        let isRunning = !this.state.isRunning;\r\n        this.setState({ isRunning });\r\n    }\r\n    toggleWeightWallToggle = () => {\r\n        const weightWallToggle = !this.state.weightWallToggle;\r\n        this.setState({ weightWallToggle });\r\n    }\r\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // Function to create Node object\r\n    createNode = (row, col) => {\r\n        // returns a javascript object denoting a node\r\n        return {\r\n            row,\r\n            col,\r\n            isStart:\r\n                row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL,\r\n            isFinish:\r\n                row === this.state.FINISH_NODE_ROW &&\r\n                col === this.state.FINISH_NODE_COL,\r\n            isVisited: false,\r\n            isWall: false,\r\n            parent: null,\r\n            isNode: true,\r\n            weight: 1,\r\n            costFromSource: (row === this.state.START_NODE_ROW && col === this.state.START_NODE_COL) ? 0 : Number.POSITIVE_INFINITY,\r\n        };\r\n    };\r\n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // grid related functions\r\n    // creates initial grid\r\n    getInitialGrid = (\r\n        rowCount = this.state.ROW_COUNT,\r\n        colCount = this.state.COLUMN_COUNT,\r\n    ) => {\r\n        const initialGrid = [];\r\n        for (let row = 0; row < rowCount; row++) {\r\n            const currentRow = [];\r\n            for (let col = 0; col < colCount; col++) {\r\n                currentRow.push(this.createNode(row, col));\r\n            }\r\n            initialGrid.push(currentRow);\r\n        }\r\n        return initialGrid;\r\n    };\r\n\r\n    // clear all animations from the grid\r\n    clearGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish && !node.isWall) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                        if (node.isStart) node.costFromSource = 0;\r\n                        else node.costFromSource = Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    \r\n    // clear all walls and weights from the grid\r\n    clearWallsandWeights = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (node.isWall) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        node.costFromSource = Number.POSITIVE_INFINITY;\r\n                    }\r\n                    if (node.weight !== 1) {\r\n                        node.weight = 1;\r\n                        node.costFromSource = node.isStart ? 0 : Number.POSITIVE_INFINITY;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n\r\n    // reset the grid\r\n    resetGrid = () => {\r\n        if (!this.state.isRunning) {\r\n            let grid = this.state.grid;\r\n\r\n            for (const row of grid) {\r\n                for (const node of row) {\r\n                    if (!node.isStart && !node.isFinish) {\r\n                        document.getElementById(\r\n                            `node-${node.row}-${node.col}`\r\n                        ).className = 'node';\r\n                        node.isVisited = false;\r\n                        node.parent = null;\r\n                        node.isWall = false;\r\n                        node.weight = 1;\r\n                    }\r\n                    else if (node.isStart || node.isFinish) {\r\n                        node.parent = null;\r\n                        node.isVisited = false;\r\n                        node.weight = 1;\r\n                    }\r\n                }\r\n            }\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // mouse event handlers\r\n    // fires on onMouseDown\r\n    onCellDown = (row, col) => {\r\n        if (!this.state.isRunning && !this.state.weightWallToggle) {\r\n\r\n            const grid = this.state.grid;\r\n            if (!this.state.mouseIsPressed) {\r\n                const mouseIsPressed = !this.state.mouseIsPressed;\r\n                this.setState({ mouseIsPressed });\r\n                const currentNode = grid[row][col];\r\n                if (!currentNode.isStart && !currentNode.isFinish) {\r\n                    if (currentNode.isWall) {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                        currentNode.isWall = false;\r\n                    }\r\n                    else {\r\n                        document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                        currentNode.isWall = true;\r\n                        currentNode.weight = 1;\r\n                    }\r\n                }\r\n                else if (currentNode.isStart) {\r\n                    const startNodePressed = !this.state.startNodePressed;\r\n                    this.setState({ startNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                    currentNode.isStart = false;\r\n                }\r\n                else if (currentNode.isFinish) {\r\n                    const finishNodePressed = !this.state.finishNodePressed;\r\n                    this.setState({ finishNodePressed });\r\n                    document.getElementById(`node-${row}-${col}`).className = 'node';\r\n                    currentNode.isFinish = false;\r\n                }\r\n            }\r\n        }\r\n        else if (!this.state.isRunning && this.state.weightWallToggle) {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if (!currentNode.isWall) {\r\n                currentNode.weight = currentNode.weight + 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // fires on onMouseEnter\r\n    onCellEnter = (row, col) => {\r\n        if (!this.state.isRunning && this.state.mouseIsPressed) {\r\n            const grid = this.state.grid;\r\n            const currentNode = grid[row][col];\r\n            if (!currentNode.isStart && !currentNode.isFinish && !this.state.startNodePressed && !this.state.finishNodePressed) {\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n                currentNode.isWall = true;\r\n                currentNode.weight = 1;\r\n            }\r\n            else if (this.state.startNodePressed) {\r\n                const START_NODE_ROW = row;\r\n                const START_NODE_COL = col;\r\n                this.setState({ START_NODE_ROW, START_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            }\r\n            else if (this.state.finishNodePressed) {\r\n                const FINISH_NODE_ROW = row;\r\n                const FINISH_NODE_COL = col;\r\n                this.setState({ FINISH_NODE_ROW, FINISH_NODE_COL });\r\n                document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    // fires on onMouseLeave\r\n    onCellLeave = (row, col) => {\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            if (!grid[row][col].isFinish && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isFinish) document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            if (!grid[row][col].isStart && !grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node';\r\n            else if (grid[row][col].isStart) document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            else if (grid[row][col].isWall) document.getElementById(`node-${row}-${col}`).className = 'node node-wall';\r\n        }\r\n    }\r\n\r\n    // fires on onMouseUp\r\n    onCellRelease = () => {\r\n        const mouseIsPressed = false;\r\n        const grid = this.state.grid;\r\n        if (this.state.startNodePressed) {\r\n            const row = this.state.START_NODE_ROW;\r\n            const col = this.state.START_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-start';\r\n            grid[row][col].isStart = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        else if (this.state.finishNodePressed) {\r\n            const row = this.state.FINISH_NODE_ROW;\r\n            const col = this.state.FINISH_NODE_COL;\r\n            document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\r\n            grid[row][col].isFinish = true;\r\n            grid[row][col].isWall = false;\r\n        }\r\n        const startNodePressed = false;\r\n        const finishNodePressed = false;\r\n        this.setState({ mouseIsPressed, startNodePressed, finishNodePressed, grid });\r\n    }\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // animation functions\r\n    // backtraces shortest path from finishNode to startNode\r\n    getNodesInShortestPathOrder(finishNode) {\r\n        const nodesInShortestPathOrder = [];\r\n        let currentNode = finishNode;\r\n        while (currentNode !== null) {\r\n            nodesInShortestPathOrder.unshift(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        return nodesInShortestPathOrder;\r\n    }\r\n\r\n    // resposible for animating the grid\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            this.clearGrid();\r\n            this.toggleIsRunning();\r\n            const { grid } = this.state;\r\n            const startNode =\r\n                grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode =\r\n                grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            let visitedNodesInOrder;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n                    break;\r\n                case 'BFS':\r\n                    visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n                    break;\r\n                case 'DFS':\r\n                    visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n                    break;\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n\r\n            const nodesInShortestPathOrder = this.getNodesInShortestPathOrder(finishNode);\r\n            nodesInShortestPathOrder.push('end');\r\n            this.animate(visitedNodesInOrder, nodesInShortestPathOrder);\r\n        }\r\n    }\r\n    animate(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n        for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n            if (i === visitedNodesInOrder.length) {\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 2 * i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                const nodeClassName = document.getElementById(\r\n                    `node-${node.row}-${node.col}`,\r\n                ).className;\r\n                if (\r\n                    nodeClassName !== 'node node-start' &&\r\n                    nodeClassName !== 'node node-finish'\r\n                ) {\r\n                    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                        'node node-visited';\r\n                }\r\n            }, 2 * i);\r\n        }\r\n    }\r\n\r\n    // responsible for animating shortest path\r\n    animateShortestPath(nodesInShortestPathOrder) {\r\n        for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n            if (nodesInShortestPathOrder[i] === 'end') {\r\n                setTimeout(() => {\r\n                    this.toggleIsRunning();\r\n                }, i * 50);\r\n            } else {\r\n                setTimeout(() => {\r\n                    const node = nodesInShortestPathOrder[i];\r\n                    const nodeClassName = document.getElementById(\r\n                        `node-${node.row}-${node.col}`,\r\n                    ).className;\r\n                    if (\r\n                        nodeClassName !== 'node node-start' &&\r\n                        nodeClassName !== 'node node-finish'\r\n                    ) {\r\n                        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                            'node node-shortest-path';\r\n                    }\r\n                }, i * 40);\r\n            }\r\n        }\r\n    }\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // maze handler\r\n    mazes = (mazeType) => {\r\n        if (!this.state.isRunning) {\r\n            const startNode = this.state.grid[this.state.START_NODE_ROW][this.state.START_NODE_COL];\r\n            const finishNode = this.state.grid[this.state.FINISH_NODE_ROW][this.state.FINISH_NODE_COL];\r\n            let grid = this.state.grid;\r\n            switch (mazeType) {\r\n                case 'maze':\r\n                    grid = maze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n                    break;\r\n                case 'hSkew':\r\n                    grid = horizontalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n                    break;\r\n                case 'vSkew':\r\n                    grid = verticalSkewMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n                    break;\r\n                case 'kruskals':\r\n                    grid = kruskalMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n                    break;\r\n                case 'prims':\r\n                    grid = primMaze(this.state.ROW_COUNT, this.state.COLUMN_COUNT, startNode, finishNode);\r\n                    break;\r\n                case 'weightMaze':\r\n                    grid = weightMaze(grid);\r\n                    break;\r\n                case 'wallMaze':\r\n                    grid = wallMaze(grid);\r\n                    break;\r\n            }\r\n            this.setState({ grid });\r\n        }\r\n    }\r\n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    // lifecycle functions\r\n    componentWillMount = () => {\r\n        const ROW_COUNT = 2 * Math.floor(Math.floor((document.documentElement.clientHeight) / 25) / 2) - 3;\r\n        const COLUMN_COUNT = 2 * Math.floor(Math.floor(document.documentElement.clientWidth / 25) / 2) - 1;\r\n        const START_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const FINISH_NODE_ROW = Math.floor(ROW_COUNT / 2);\r\n        const START_NODE_COL = Math.floor(COLUMN_COUNT / 4);\r\n        const FINISH_NODE_COL = Math.floor(3 * COLUMN_COUNT / 4);\r\n        this.setState({ ROW_COUNT, COLUMN_COUNT, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL });\r\n    }\r\n    componentDidMount = () => {\r\n        const grid = this.getInitialGrid();\r\n        this.setState({ grid });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                <Navbar\r\n                    dfs={() => this.visualize('DFS')}\r\n                    bfs={() => this.visualize('BFS')}\r\n                    dijkstra={() => this.visualize('Dijkstra')}\r\n                    clearGrid={() => this.clearGrid()}\r\n                    resetGrid={() => this.resetGrid()}\r\n                    clearWallsandWeights={() => this.clearWallsandWeights()}\r\n                    mazify={() => this.mazes('maze')}\r\n                    hmazify={() => this.mazes('hSkew')}\r\n                    vmazify={() => this.mazes('vSkew')}\r\n                    kruskalMazify={() => this.mazes('kruskals')}\r\n                    primMazify={() => this.mazes('prims')}\r\n                    weightMazify={() => this.mazes('weightMaze')}\r\n                    wallMazify={() => this.mazes('wallMaze')}\r\n                    navbarHeight={this.navbarHeight}\r\n                    weightWallToggle={() => this.toggleWeightWallToggle()}\r\n                    toggleCanvas={() => this.props.toggleCanvas()}\r\n                    isCanvas={this.props.isCanvas}\r\n                ></Navbar>\r\n                <table className=\"center grid-container\" >\r\n                    <tbody className=\"grid\">\r\n                        {\r\n                            this.state.grid.map((row, rowID) => {\r\n                                return (\r\n                                    <tr key={rowID} >\r\n                                        {\r\n                                            row.map((node, nodeID) => {\r\n                                                const { row, col, isFinish, isStart, isWall, weight } = node;\r\n\r\n                                                return (\r\n                                                    <Node\r\n                                                        key={nodeID}\r\n                                                        row={row}\r\n                                                        col={col}\r\n                                                        weight={weight}\r\n                                                        isFinish={isFinish}\r\n                                                        isStart={isStart}\r\n                                                        isWall={isWall}\r\n                                                        onMouseDown={(x, y) => { this.onCellDown(x, y) }}\r\n                                                        onMouseEnter={(x, y) => this.onCellEnter(x, y)}\r\n                                                        onMouseUp={() => this.onCellRelease()}\r\n                                                        onMouseLeave={(x, y) => this.onCellLeave(x, y)}\r\n                                                    ></Node>\r\n                                                );\r\n                                            })\r\n                                        }\r\n\r\n                                    </tr>\r\n                                );\r\n                            })\r\n                        }\r\n                    </tbody>\r\n                </table>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","export function wallMaze(grid) {\r\n    grid.forEach(row => {\r\n        row.forEach(node => {\r\n            node.isWall = false;\r\n            if (!node.isStart && !node.isFinish) {\r\n                const random = Math.floor(Math.random() * 4);\r\n                if (random === 0) {\r\n                    node.isWall = true;\r\n                    node.weight = 1;\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return grid;\r\n}","// BFS\r\n\r\nexport function bfs (grid,startNode,finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n    const childDirections = [[1,0],[0,1],[-1,0],[0,-1]] ;\r\n\r\n    while(bfsQueue.length)\r\n    {\r\n        const currentNode = bfsQueue.shift();\r\n        if (currentNode === finishNode) return visitedNodesInOrder;\r\n        visitedNodesInOrder.push(currentNode);\r\n        const {row,col} = currentNode;\r\n\r\n        childDirections.forEach(direction => {\r\n            let x = row + direction[0];\r\n            let y = col + direction[1];\r\n\r\n            if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && !grid[x][y].isWall && !grid[x][y].isVisited)\r\n            {\r\n                bfsQueue.push(grid[x][y]);\r\n                grid[x][y].isVisited = true;\r\n                grid[x][y].parent = currentNode;\r\n            }\r\n        });\r\n    }\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n","import React, { useRef, useState } from \"react\";\r\n\r\nexport const CanvasContext = React.createContext();\r\n\r\nexport const CanvasProvider = ({ children }) => {\r\n    const [isDrawing, setIsDrawing] = useState(false);\r\n\r\n    const [nodeDrawing, setNodeDrawing] = useState(true);\r\n    const [index,setIndex] = useState(0);\r\n    const canvasRef = useRef(null);\r\n    const contextRef = useRef(null);\r\n\r\n    const prepareCanvas = (height, width) => {\r\n        const canvas = canvasRef.current\r\n        canvas.width = width;\r\n        canvas.height = height;\r\n        canvas.style.width = `${width}px`;\r\n        canvas.style.height = `${height}px`;\r\n\r\n        const context = canvas.getContext(\"2d\");\r\n        context.lineCap = \"round\";\r\n        context.strokeStyle = \"black\";\r\n        context.lineWidth = 1;\r\n        contextRef.current = context;\r\n    };\r\n\r\n    const toggleNodeDrawing = () => {\r\n        setNodeDrawing(!nodeDrawing);\r\n    }\r\n\r\n    const [nodesOfGraph, pushNode] = useState([]);\r\n\r\n    const squareDistance = (node, x, y) => {\r\n        return Math.pow(node.centerX - x, 2) + Math.pow(node.centerY - y, 2);\r\n    }\r\n\r\n    const [startNode, setStartNode] = useState(null);\r\n    let currentCoordinates = null;\r\n    const whichNode = (x, y) => {\r\n        let node = null;\r\n        for (let i = 0; i < nodesOfGraph.length; i++) {\r\n            if (squareDistance(nodesOfGraph[i], x, y) <= 1600) {\r\n                node = nodesOfGraph[i];\r\n                return node;\r\n            }\r\n        }\r\n        return node;\r\n    }\r\n\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n\r\n    const startDrawing = ({ nativeEvent }) => {\r\n        if (nodeDrawing) {\r\n            const { offsetX, offsetY } = nativeEvent;\r\n            if (whichNode(offsetX, offsetY)) return;\r\n\r\n            setIndex((prevIndex)=> prevIndex + 1);\r\n            const canvas = canvasRef.current;\r\n            const ctx = canvas.getContext(\"2d\");\r\n\r\n\r\n            ctx.beginPath();\r\n            ctx.arc(offsetX, offsetY, 20, 0, Math.PI * 2, false);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n            \r\n            const node = {\r\n                centerX: offsetX,\r\n                centerY: offsetY,\r\n                id: index,\r\n                children: [],\r\n                isVisited:false,\r\n                parent:null,\r\n                costFromSource:Number.POSITIVE_INFINITY,\r\n            };\r\n            pushNode([...nodesOfGraph, node]);\r\n            writeText({text : `${node.id}`,x : node.centerX-10,y : node.centerY-10});\r\n        }\r\n        else {\r\n            if (!isDrawing) {\r\n                const { offsetX, offsetY } = nativeEvent;\r\n\r\n                const start = whichNode(offsetX, offsetY);\r\n                setStartNode(start);\r\n\r\n                if (start) {\r\n                    setIsDrawing(true);\r\n                    currentCoordinates = { x: offsetX, y: offsetY };\r\n                    contextRef.current.beginPath();\r\n                    contextRef.current.moveTo(offsetX, offsetY);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    const [currentEdgeWeight,setCurrentEdgeWeight] = useState(0);\r\n    const finishDrawing = () => {\r\n        if (!nodeDrawing) {\r\n\r\n            if (isDrawing && currentCoordinates) {\r\n                setIsDrawing(false);\r\n\r\n                const { x, y } = currentCoordinates;\r\n                const end = whichNode(x, y);\r\n\r\n                if (!end) {\r\n                    contextRef.current.closePath();\r\n                }\r\n                else if (end.id === startNode.id) {\r\n                    contextRef.current.closePath();\r\n                }\r\n                else {\r\n                    contextRef.current.moveTo(startNode.centerX, startNode.centerY);\r\n                    contextRef.current.lineTo(end.centerX, end.centerY);\r\n                    contextRef.current.stroke();\r\n                    contextRef.current.closePath();\r\n                    \r\n                    let c =false;\r\n                    for(let i=0;i<startNode.children.length;i++){\r\n                        if(startNode.children[i].node === end){\r\n                            c = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if(!c){\r\n                        const weight = currentEdgeWeight;\r\n                        const x = (startNode.centerX + end.centerX) / 2;\r\n                        const y = (startNode.centerY + end.centerY) / 2;\r\n                        startNode.children.push({ node: end, weight });\r\n                        end.children.push({ node: startNode, weight });\r\n                        writeText({ text: (weight?weight:''), x, y });\r\n                    }\r\n                }\r\n                currentCoordinates = null;\r\n                setStartNode(null);\r\n            }\r\n        }\r\n    };\r\n\r\n    const draw = ({ nativeEvent }) => {\r\n        const { offsetX, offsetY } = nativeEvent;\r\n        if (!nodeDrawing) {\r\n            if (isDrawing) {\r\n                currentCoordinates = { x: offsetX, y: offsetY };\r\n            }\r\n        }\r\n    };\r\n\r\n    const clearCanvas = () => {\r\n        const canvas = canvasRef.current;\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    return (\r\n        <CanvasContext.Provider\r\n            value={{\r\n                canvasRef,\r\n                contextRef,\r\n                prepareCanvas,\r\n                startDrawing,\r\n                finishDrawing,\r\n                clearCanvas,\r\n                draw,\r\n                toggleNodeDrawing,\r\n                nodeDrawing,\r\n                nodesOfGraph,\r\n                pushNode,\r\n                setIndex,\r\n                setCurrentEdgeWeight,\r\n            }}\r\n        >\r\n            {children}\r\n        </CanvasContext.Provider>\r\n    );\r\n};\r\n\r\n","import React, { useEffect, useContext, useLayoutEffect, useState } from \"react\";\r\nimport { CanvasContext } from \"./CanvasContext\";\r\n\r\nfunction CanvasBoard(props) {\r\n    const {\r\n        canvasRef,\r\n        prepareCanvas,\r\n        startDrawing,\r\n        finishDrawing,\r\n        draw,\r\n        toggleNodeDrawing,\r\n        nodeDrawing,\r\n        nodesOfGraph,\r\n        clearCanvas,\r\n        pushNode,\r\n        setIndex,\r\n        setCurrentEdgeWeight,\r\n    } = useContext(CanvasContext);\r\n\r\n    const emptyTheGraph = () => {\r\n        pushNode([]);\r\n        setIndex(1);\r\n    }\r\n\r\n    useEffect(() => {\r\n        prepareCanvas(props.height, props.width);\r\n        clearCanvas();\r\n        props.settingStartNode(null);\r\n        props.settingEndNode(null);\r\n    }, []);\r\n    const [startNode, setStartNode] = useState(0);\r\n    const [endNode, setEndNode] = useState(0);\r\n    useEffect(() => {\r\n        props.settingGraph(nodesOfGraph);\r\n        if (!startNode) props.settingStartNode((nodesOfGraph.length ? nodesOfGraph[0] : null));\r\n        if (!endNode) props.settingEndNode(nodesOfGraph.length ? nodesOfGraph[nodesOfGraph.length - 1] : null);\r\n        if (props.emptyGraphCall) {\r\n            emptyTheGraph();\r\n            props.toggleEmptyTheGraph();\r\n        }\r\n    }, [nodesOfGraph, props.emptyGraphCall]);\r\n\r\n\r\n\r\n    const startNodeUpdate = (event) => {\r\n        const startIndex = event.target.value;\r\n        setStartNode(startIndex);\r\n        if (startIndex != 0 && startIndex <= nodesOfGraph.length) props.settingStartNode(nodesOfGraph[startIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n    const endNodeUpdate = (event) => {\r\n        const endIndex = event.target.value;\r\n        setEndNode(endIndex);\r\n        if (endIndex != 0 && endIndex <= nodesOfGraph.length) props.settingEndNode(nodesOfGraph[endIndex - 1]);\r\n        else alert('Not a valid start node');\r\n    }\r\n\r\n///////////////////////////////////////// try doing without usingStates\r\n    const [weightNodeA,setWeightNodeA] = useState(0);\r\n    const [weightNodeB, setWeightNodeB] = useState(0);\r\n    const [weight,setWeight] = useState(0);\r\n    const weightNodeAUpdate = (event)=>{\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeA(nodeIndex);\r\n    }\r\n    const weightNodeBUpdate = (event) => {\r\n        const nodeIndex = event.target.value;\r\n        setWeightNodeB(nodeIndex);\r\n    }\r\n    const weightUpdate=(event)=>{\r\n        const weight=parseInt(event.target.value);\r\n        setWeight(weight);\r\n        setCurrentEdgeWeight(weight);\r\n    }\r\n    const writeText = (info, style = {}) => {\r\n        const canvas = canvasRef.current;\r\n        const ctx = canvas.getContext(\"2d\");\r\n        const { text, x, y } = info;\r\n        const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n        ctx.beginPath();\r\n        ctx.font = fontSize + 'px ' + fontFamily;\r\n        ctx.textAlign = textAlign;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.fillStyle = color;\r\n        ctx.fillText(text, x, y);\r\n        ctx.stroke();\r\n    }\r\n    const addWeightToEdge = () => {\r\n        const startId = weightNodeA;\r\n        const endId = weightNodeB;\r\n        const weightFinal = weight;\r\n        if(startId > 0 && endId>0 && startId<=nodesOfGraph.length && endId<=nodesOfGraph.length){\r\n            const startNode = nodesOfGraph[startId - 1];\r\n            const endNode = nodesOfGraph[endId - 1];\r\n            for (let i = 0; i < startNode.children.length; i++) {\r\n                let { node } = startNode.children[i];\r\n                if (node === endNode) {\r\n                    startNode.children[i].weight = weightFinal;\r\n                    for (let j = 0; j < endNode.children.length; j++) {\r\n                        let { node, weight } = endNode.children[j];\r\n                        if (node === startNode) {\r\n                            endNode.children[j].weight = weightFinal;\r\n                            const x = (startNode.centerX + endNode.centerX)/2;\r\n                            const y = (startNode.centerY + endNode.centerY)/2;\r\n                            writeText({text:weightFinal,x,y});\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        alert('No such edge exists');\r\n    }\r\n/////////////////////////////////////////////////////////////////////////\r\n    let edgeWeightInput = <div><a>Current edge weight</a>\r\n        <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value={weight} /></div>;\r\n    if(nodeDrawing){\r\n        edgeWeightInput = <div></div>\r\n    }\r\n    return (\r\n        <>\r\n            {/* <section id=\"canvas-container\"> */}\r\n            <div id=\"wrapper\" class=\"toggled\">\r\n                <div id=\"sidebar-wrapper\">\r\n                    <ul className=\"sidebar-nav\">\r\n                        <li className=\"sidebar-brand\"> <a href=\"#\"> Control Panel </a> </li>\r\n                        <li> \r\n                            <a href=\"#\" onClick={toggleNodeDrawing}>Add {nodeDrawing ? 'Edge' : 'Node'}</a> \r\n                            {edgeWeightInput}\r\n                        </li>\r\n                        <li>\r\n                            <a>Start Node</a>\r\n                            <input id=\"startValue\" type = \"number\" placeholder={nodesOfGraph.length ? '1' : '0'} onChange={startNodeUpdate} />\r\n                            <a>End Node</a>\r\n                            <input id=\"endValue\" type=\"number\" placeholder={nodesOfGraph.length} onChange={endNodeUpdate} />\r\n                        </li>\r\n                        {/* <li>\r\n                            <a>Add Weight</a>\r\n                            <a>Start Node</a>\r\n                            <input onChange={weightNodeAUpdate} type=\"number\" value ={weightNodeA}/>\r\n                            <a>End Node</a>\r\n                            <input onChange={weightNodeBUpdate} type=\"number\" value = {weightNodeB}/>\r\n                            <a>Weight</a>\r\n                            <input id=\"edgeWeight\" onChange={weightUpdate} type=\"number\" value = {weight}/>\r\n                            <button onClick = {addWeightToEdge}>Submit</button>\r\n                        </li> */}\r\n                    </ul>\r\n                </div>\r\n            </div>\r\n            <canvas id='canvas'\r\n                className=\"centercanvas\"\r\n                onMouseDown={props.isRunning?()=>{}:startDrawing}\r\n                onMouseUp={props.isRunning ? () => { } :finishDrawing}\r\n                onMouseMove={draw}\r\n                ref={canvasRef}\r\n            ></canvas>\r\n\r\n            <button ></button>\r\n            <br></br>\r\n            {/* </section> */}\r\n        </>\r\n    )\r\n}\r\n\r\nexport default CanvasBoard;","// BFS\r\nconst createEdge = (nodeA,nodeB)=>{\r\n    if(nodeA === null){\r\n        const xB = nodeB.centerX;\r\n        const yB = nodeB.centerY;\r\n        return {xB,yB,xB,yB};\r\n    }\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = {xA,yA,xB,yB};\r\n    return edge;\r\n}\r\n\r\nexport function bfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n    let bfsQueue = [startNode];\r\n    startNode.isVisited = true;\r\n\r\n    while (bfsQueue.length) {\r\n        const currentNode = bfsQueue.shift();\r\n        visitedNodesInOrder.push(currentNode);\r\n        visitedEdgesInOrder.push(createEdge(currentNode.parent, currentNode));\r\n        if (currentNode === finishNode) {\r\n            return { visitedNodesInOrder, visitedEdgesInOrder }\r\n        };\r\n        currentNode.children.forEach(childObject => {\r\n            const child = childObject.node;\r\n            if(!child.isVisited){\r\n                child.isVisited = true;\r\n                child.parent = currentNode;\r\n                bfsQueue.push(child);\r\n            }\r\n        });\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// DFS\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(node) {\r\n    const childElements = [];\r\n\r\n    node.children.forEach((childObject) => {\r\n        const child = childObject.node;\r\n        if (!child.isVisited) {\r\n            childElements.push(child);\r\n        }\r\n    });\r\n\r\n    return childElements;\r\n}\r\n\r\nexport function dfs(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [startNode];\r\n    const visitedEdgesInOrder = [];\r\n    startNode.isVisited = true;\r\n    let currentNode = startNode;\r\n    let dfsStack = [currentNode];\r\n    while (dfsStack.length) {\r\n        if (currentNode === finishNode) { \r\n            return { visitedNodesInOrder, visitedEdgesInOrder }; \r\n        }\r\n        const childElements = getChildren(currentNode);\r\n        if (childElements.length) {\r\n            childElements[0].parent = currentNode;\r\n            visitedEdgesInOrder.push(createEdge(currentNode, childElements[0]));\r\n            currentNode = childElements[0];\r\n            currentNode.isVisited = true;\r\n            visitedNodesInOrder.push(currentNode);\r\n            dfsStack.push(currentNode);\r\n        }\r\n        else {\r\n            dfsStack.pop();\r\n            currentNode = dfsStack[dfsStack.length - 1];\r\n        }\r\n    }\r\n    return { visitedNodesInOrder, visitedEdgesInOrder };\r\n}","// Dijkstra\r\n// still raw\r\n\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nfunction getChildren(currentNode,visitedEdgesInOrder) {\r\n    const childNodes = [];\r\n    currentNode.children.forEach(childObject => {\r\n        const { node, weight } = childObject;\r\n        if (!node.isVisited) {\r\n            childNodes.push(node);\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode,node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n        else if (node.isVisited) {\r\n            if (node.costFromSource > currentNode.costFromSource + weight) {\r\n                node.parent = currentNode;\r\n                visitedEdgesInOrder.push(createEdge(currentNode, node));\r\n            }\r\n            node.costFromSource = Math.min(node.costFromSource, currentNode.costFromSource + weight);\r\n        }\r\n    })\r\n    return childNodes;\r\n}\r\n\r\nfunction extractMinIndex(dijkstraPQ) {\r\n    let minNode = dijkstraPQ[0];\r\n    let minNodeIndex = 0;\r\n    for (let i = 1; i < dijkstraPQ.length; i++) {\r\n        let currentNode = dijkstraPQ[i];\r\n        if (minNode.costFromSource > currentNode.costFromSource) {\r\n            minNode = currentNode;\r\n            minNodeIndex = i;\r\n        }\r\n    }\r\n    return minNodeIndex;\r\n}\r\n\r\nexport function dijkstra(graph, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const visitedEdgesInOrder = [];\r\n\r\n    let currentNode;\r\n    let dijkstraPQ = [startNode];\r\n    startNode.costFromSource = 0;\r\n    startNode.isVisited = true;\r\n    while (dijkstraPQ.length) {\r\n\r\n        const minIndex = extractMinIndex(dijkstraPQ);\r\n        currentNode = dijkstraPQ[minIndex];\r\n        if (currentNode === finishNode) {\r\n            visitedNodesInOrder.push(currentNode);\r\n            return { visitedNodesInOrder, visitedEdgesInOrder };\r\n        }\r\n\r\n        visitedNodesInOrder.push(currentNode);\r\n        const childNodes = getChildren(currentNode,visitedEdgesInOrder);\r\n        childNodes.forEach(node => {\r\n            dijkstraPQ.push(node);\r\n            node.isVisited = true;\r\n        });\r\n        dijkstraPQ.splice(minIndex, 1);\r\n    }\r\n    return {visitedNodesInOrder,visitedEdgesInOrder};\r\n}\r\n\r\n","const createEdge = (nodeA, nodeB) => {\r\n    const xA = nodeA.centerX;\r\n    const yA = nodeA.centerY;\r\n    const xB = nodeB.centerX;\r\n    const yB = nodeB.centerY;\r\n    const edge = { xA, yA, xB, yB };\r\n    return edge;\r\n}\r\n\r\nconst writeText = (info, style = {}) => {\r\n    const canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    const { text, x, y } = info;\r\n    const { fontSize = 20, fontFamily = 'Arial', color = 'black', textAlign = 'left', textBaseline = 'top' } = style;\r\n\r\n    ctx.beginPath();\r\n    ctx.font = fontSize + 'px ' + fontFamily;\r\n    ctx.textAlign = textAlign;\r\n    ctx.textBaseline = textBaseline;\r\n    ctx.fillStyle = color;\r\n    ctx.fillText(text, x, y);\r\n    ctx.stroke();\r\n}\r\n\r\nexport function visitAllEdges(graph) {\r\n    let canvas = document.getElementById('canvas');\r\n    const ctx = canvas.getContext(\"2d\");\r\n    ctx.fillStyle = \"white\";\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        writeText({ text: `${node.id}`, x: node.centerX - 35, y: node.centerY - 35 });\r\n        if (!node.isVisited) {\r\n\r\n            ctx.strokeStyle = \"#000000\";\r\n            let { centerX, centerY } = node;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, true);\r\n            ctx.stroke();\r\n            ctx.closePath();\r\n\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        const { xA, yA, xB, yB } = edge;\r\n                        const x = (xA + xB) / 2;\r\n                        const y = (yA + yB) / 2;\r\n                        const weight = (childObject.weight ? childObject.weight:'');\r\n                        writeText({text:weight,x,y});\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(xA, yA);\r\n                        ctx.lineTo(xB, yB);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        ctx.beginPath();\r\n                        ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                        ctx.stroke();\r\n                        ctx.closePath();\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n    });\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function kruskalsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const graphEdges = [];\r\n    graph.forEach((node) => {\r\n        if (!node.isVisited) {\r\n            let bfsQueue = [node];\r\n            while (bfsQueue.length) {\r\n                const currentNode = bfsQueue.shift();\r\n                currentNode.isVisited = true;\r\n                currentNode.children.forEach(childObject => {\r\n                    const child = childObject.node;\r\n                    if (!child.isVisited) {\r\n                        const edge = createEdge(currentNode, child);\r\n                        graphEdges.push(edge);\r\n                        bfsQueue.push(child);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    graphEdges.sort(compare);\r\n\r\n    const kruskalSelectedEdges = [];\r\n    graphEdges.forEach((edge) => {\r\n        const {nodeA,nodeB} = edge;\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            kruskalSelectedEdges.push(edge);\r\n            disjointSet.union(nodeA,nodeB);\r\n        }\r\n    });\r\n\r\n    return kruskalSelectedEdges;\r\n\r\n}","import DisjointSet from '../../Data Structures/disjointSet';\r\n\r\nconst getEdgeWeight = (nodeA, nodeB) => {\r\n    for (let i = 0; i < nodeA.children.length; i++) {\r\n        const { node, weight } = nodeA.children[i];\r\n        if (node === nodeB) {\r\n            return weight;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nconst createEdge = (nodeA, nodeB) => {\r\n    const edgeWeight = getEdgeWeight(nodeA, nodeB);\r\n    const edge = { nodeA, nodeB, edgeWeight };\r\n    return edge;\r\n}\r\n\r\nfunction compare(edgeA, edgeB) {\r\n    return edgeA.edgeWeight - edgeB.edgeWeight;\r\n}\r\n\r\nexport function primsMST(graph) {\r\n    let disjointSet = new DisjointSet((node) => {\r\n        return node.id;\r\n    });\r\n    graph.forEach((node) => {\r\n        node.isVisited = false;\r\n        node.parent = null;\r\n        node.costFromSource = Number.POSITIVE_INFINITY;\r\n        disjointSet.makeSet(node);\r\n    });\r\n    const primSelectedEdges = [];\r\n\r\n    let currentNode = graph[0];\r\n    const graphEdgesQueue = [];\r\n    for(let i=0;i<currentNode.children.length;i++){\r\n        const {node,weight} = currentNode.children[i];\r\n        graphEdgesQueue.push(createEdge(currentNode,node));\r\n    }\r\n    graphEdgesQueue.sort(compare);\r\n    \r\n    while(graphEdgesQueue.length){\r\n        const { nodeA, nodeB} = graphEdgesQueue[0];\r\n        if(!disjointSet.inSameSet(nodeA,nodeB)){\r\n            disjointSet.union(nodeA,nodeB);\r\n            currentNode = graphEdgesQueue[0].nodeB;\r\n            primSelectedEdges.push(graphEdgesQueue.shift());\r\n            for (let i = 0; i < currentNode.children.length; i++) {\r\n                const { node } = currentNode.children[i];\r\n                graphEdgesQueue.push(createEdge(currentNode, node));\r\n            }\r\n            graphEdgesQueue.sort(compare);\r\n        }\r\n        else graphEdgesQueue.shift();\r\n    }\r\n\r\n    return primSelectedEdges;\r\n}","import React, { useContext } from 'react';\r\nimport './Canvas.css';\r\nimport Navbar from '../Navbar';\r\nimport CanvasBoard from './CanvasBoard';\r\nimport { CanvasProvider } from './CanvasContext';\r\nimport { bfs } from './Algorithms/bfs';\r\nimport { dfs } from './Algorithms/dfs';\r\nimport { dijkstra } from './Algorithms/dijkstra';\r\nimport { visitAllEdges } from \"./Algorithms/visitAllEdges\";\r\nimport { kruskalsMST } from './Algorithms/kruskals';\r\nimport { primsMST } from './Algorithms/prims';\r\n\r\nclass Canvas extends React.Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            navbarHeight: 0,\r\n            height: 0,\r\n            width: 0,\r\n            graphOfNodes: [],\r\n            isRunning: false,\r\n            emptyGraphCall: false,\r\n            startNode: null,\r\n            endNode: null,\r\n        }\r\n    }\r\n    // for togling b/w grid and canvas\r\n    toggleCanvas = () => {\r\n        const canvasOrGrid = !this.state.canvasOrGrid;\r\n        this.setState({ canvasOrGrid });\r\n        this.props.toggleCanvas();\r\n    }\r\n\r\n    toggleEmptyTheGraph = () => {\r\n        const emptyGraphCall = !this.state.emptyGraphCall;\r\n        this.setState({ emptyGraphCall });\r\n    }\r\n    \r\n\r\n    settingStartNode = (startNode) => {\r\n        this.setState({ startNode });\r\n    }\r\n    settingEndNode = (endNode) => {\r\n        this.setState({ endNode });\r\n    }\r\n    settingGraph = (graphOfNodes) => {\r\n        this.setState({ graphOfNodes });\r\n    }\r\n\r\n    redrawGraph = () => {\r\n        const graphOfNodes = this.state.graphOfNodes;\r\n        visitAllEdges(graphOfNodes);\r\n    }\r\n    clearCanvas = () => {\r\n        this.setState({ emptyGraphCall: true });\r\n        const canvas = document.getElementById('canvas');\r\n        const context = canvas.getContext(\"2d\");\r\n        context.fillStyle = \"white\";\r\n        context.fillRect(0, 0, canvas.width, canvas.height);\r\n    }\r\n\r\n    visualize(algo) {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let startNode = this.state.startNode, finishNode = this.state.endNode;\r\n\r\n            let visitedNodesInOrder1;\r\n            let visitedEdgesInOrder1;\r\n            switch (algo) {\r\n                case 'Dijkstra':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dijkstra(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'BFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = bfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                case 'DFS':\r\n                    {\r\n                        const { visitedNodesInOrder, visitedEdgesInOrder } = dfs(graphOfNodes, startNode, finishNode);\r\n                        visitedNodesInOrder1 = visitedNodesInOrder;\r\n                        visitedEdgesInOrder1 = visitedEdgesInOrder;\r\n                        break;\r\n                    }\r\n                default:\r\n                    // should never get here\r\n                    break;\r\n            }\r\n            visitedNodesInOrder1.forEach(node => {\r\n                console.log(node.id, node.costFromSource);\r\n            });\r\n            this.animate(visitedNodesInOrder1, visitedEdgesInOrder1, algo, finishNode);\r\n        }\r\n    }\r\n\r\n\r\n    animate = (visitedNodesInOrder, visitedEdgesInOrder, algo, finishNode) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"green\";\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 1;\r\n\r\n        let { centerX, centerY } = visitedNodesInOrder[0];\r\n        ctx.beginPath();\r\n        ctx.moveTo(centerX, centerY);\r\n        ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n        ctx.fill();\r\n        ctx.closePath();\r\n\r\n        for (let i = 0; i < visitedEdgesInOrder.length; i++) {\r\n            const { xA, yA, xB, yB } = visitedEdgesInOrder[i];\r\n\r\n            setTimeout(() => {\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(xA, yA);\r\n                    ctx.lineTo(xB, yB);\r\n                    ctx.stroke();\r\n                    ctx.closePath();\r\n                }, 500);\r\n\r\n                setTimeout(() => {\r\n                    ctx.beginPath();\r\n                    ctx.arc(xB, yB, 20, 0, Math.PI * 2, false);\r\n                    ctx.fill();\r\n                    ctx.closePath();\r\n                }, 1000);\r\n            }, i * 1000);\r\n\r\n        }\r\n        if (visitedNodesInOrder[visitedNodesInOrder.length - 1] === finishNode) {\r\n            setTimeout(() => {\r\n                this.animateShortestPath(finishNode, visitedNodesInOrder);\r\n            }, 1000 * (visitedEdgesInOrder.length + 1) + 100);\r\n        }\r\n        else {\r\n            setTimeout(() => {\r\n                ctx.fillStyle = \"#ffffff\";\r\n                ctx.strokeStyle = '#000000';\r\n                this.setState({ isRunning: false });\r\n                alert('node not reachable');\r\n            }, 1000 * visitedNodesInOrder.length + 100);\r\n        }\r\n\r\n    }\r\n    animateShortestPath = (endNode, visitedNodesInOrder) => {\r\n        let shortestPathNodes = [];\r\n        let currentNode = endNode;\r\n        while (currentNode) {\r\n            shortestPathNodes.push(currentNode);\r\n            currentNode = currentNode.parent;\r\n        }\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.fillStyle = \"yellow\";\r\n\r\n        for (let i = shortestPathNodes.length - 1; i >= 0; i--) {\r\n            setTimeout(() => {\r\n                const node = shortestPathNodes[i];\r\n                const { centerX, centerY } = node;\r\n                ctx.beginPath();\r\n                ctx.arc(centerX, centerY, 20, 0, Math.PI * 2, false);\r\n                ctx.fill();\r\n                ctx.closePath();\r\n            }, (shortestPathNodes.length - 1 - i) * 500);\r\n        }\r\n        setTimeout(() => {\r\n            ctx.fillStyle = \"#ffffff\";\r\n            ctx.strokeStyle = '#000000';\r\n            this.setState({ isRunning: false });\r\n            shortestPathNodes = [];\r\n        }, 500 * (shortestPathNodes.length) + 1000);\r\n    }\r\n\r\n    visualizeMST = (algo) => {\r\n        if (!this.state.isRunning) {\r\n            const graphOfNodes = this.state.graphOfNodes;\r\n            if (!graphOfNodes.length) {\r\n                alert('Canvas is empty');\r\n                return;\r\n            }\r\n            this.setState({ isRunning: true });\r\n            this.redrawGraph();\r\n            let MSTedges = [];\r\n            switch (algo) {\r\n                case 'Kruskal':\r\n                    {\r\n                        MSTedges = kruskalsMST(graphOfNodes);\r\n                        break;\r\n                    }\r\n                case 'Prims':\r\n                    {\r\n                        MSTedges = primsMST(graphOfNodes);\r\n                        break;\r\n                    }\r\n                default:\r\n                    // do nothing\r\n                    break;\r\n            }\r\n            if (MSTedges.length) this.animateMST(MSTedges);\r\n            else {\r\n                // some error occurred\r\n                this.setState({ isRunning: false });\r\n            }\r\n        }\r\n    }\r\n    animateMST = (MSTedges) => {\r\n        let canvas = document.getElementById('canvas');\r\n        let ctx = canvas.getContext('2d');\r\n        ctx.strokeStyle = '#ff0000';\r\n        ctx.lineWidth = 5;\r\n\r\n        for (let i = 0; i < MSTedges.length; i++) {\r\n            setTimeout(() => {\r\n                const { nodeA, nodeB } = MSTedges[i];\r\n                const xA = nodeA.centerX;\r\n                const yA = nodeA.centerY;\r\n                const xB = nodeB.centerX;\r\n                const yB = nodeB.centerY;\r\n                ctx.beginPath();\r\n                ctx.moveTo(xA, yA);\r\n                ctx.lineTo(xB, yB);\r\n                ctx.stroke();\r\n                ctx.closePath();\r\n            }, i * 500);\r\n        }\r\n        setTimeout(() => {\r\n            ctx.strokeStyle = '#000000';\r\n            ctx.lineWidth = 1;\r\n            this.setState({ isRunning: false });\r\n        }, MSTedges.length * 500 + 100);\r\n    }\r\n\r\n\r\n    render() {\r\n        const height = document.documentElement.clientHeight - 50;\r\n        const width = document.documentElement.clientWidth - 30;\r\n        return (\r\n            <div>\r\n                <CanvasProvider>\r\n                    <Navbar\r\n                        isCanvas={this.props.isCanvas}\r\n                        toggleCanvas={() => this.toggleCanvas()}\r\n                        bfs={() => this.visualize('BFS')}\r\n                        dfs={() => this.visualize('DFS')}\r\n                        dijkstra={() => this.visualize('Dijkstra')}\r\n                        clearGrid={() => this.redrawGraph()}\r\n                        resetGrid={() => this.clearCanvas()}\r\n                        kruskalMST={() => this.visualizeMST('Kruskal')}\r\n                        primMST={() => this.visualizeMST('Prims')}\r\n                    ></Navbar>\r\n                    <CanvasBoard\r\n                        height={height}\r\n                        width={width}\r\n                        settingGraph={this.settingGraph}\r\n                        settingStartNode={this.settingStartNode}\r\n                        settingEndNode={this.settingEndNode}\r\n                        emptyGraphCall={this.state.emptyGraphCall}\r\n                        toggleEmptyTheGraph={this.toggleEmptyTheGraph}\r\n                        isRunning={this.state.isRunning}\r\n                    ></CanvasBoard>\r\n                </CanvasProvider>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Canvas;","import React from 'react';\r\nimport './App.css';\r\n// import Navbar from './Navbar';\r\nimport PathfindingVisualizer from './PathfindingVisualizer/PathfindingVisualizer'\r\nimport Canvas from './Canvas/Canvas'\r\n\r\nclass App extends React.Component{\r\n  constructor(props){\r\n    super(props);\r\n    this.state = {\r\n      canvas: false,\r\n    }\r\n  }\r\n\r\n  toggleCanvas = ()=>{\r\n    const canvas = !this.state.canvas;\r\n    this.setState({canvas});\r\n  }\r\n\r\n  render(){\r\n\r\n    if(!this.state.canvas){\r\n      return (\r\n        <div className=\"App\">\r\n          <PathfindingVisualizer\r\n              toggleCanvas={()=>this.toggleCanvas()}\r\n              isCanvas = {this.state.canvas}\r\n          ></PathfindingVisualizer>\r\n        </div>\r\n      )\r\n    }\r\n    else {\r\n      return (\r\n        <div className=\"App\">\r\n          <Canvas\r\n            toggleCanvas={() => this.toggleCanvas()}\r\n            isCanvas={this.state.canvas}\r\n          ></Canvas>\r\n        </div>\r\n      )\r\n    } \r\n  }\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n"],"sourceRoot":""}